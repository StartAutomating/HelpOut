<?xml version="1.0" encoding="utf-16"?>
<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>HelpInfo</Name>
    <Members>
      <ScriptMethod>
        <Name>ToJson</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Convert HelpInfo to json
.DESCRIPTION
    Converts a HelpInfo object to a JSON representation of the object.
.EXAMPLE
    (Get-Help Get-Help).ToJson()
#&gt;

param()

$helpObject = $this
[Ordered]@{
    Synopsis = $helpObject.Synopsis
    Description = $helpObject.Description.text -join ([Environment]::NewLine * 2)
    Parameters = @(foreach ($parameter in $helpObject.Parameters) {
        [Ordered]@{
            Name = $parameter.Name
            Type = $parameter.Type.Name
            Description = $parameter.Description.text -join ([Environment]::NewLine * 2)
            Required = $parameter.Required -match $true
            Position = if ($null -ne ($parameter.Position -as [int])) {
                $parameter.Position -as [int]
            } else {
                -1
            }
            Aliases = $parameter.Aliases
            DefaultValue = $parameter.DefaultValue
            Globbing = $parameter.Globbing -match $true
            PipelineInput = $parameter.PipelineInput
            variableLength = $parameter.variableLength -match $true
        }
    })
    Notes = @($helpObject.alertSet.alert.text)
    CommandType = $helpObject.Category
    Component = @($helpObject.Component)
    Inputs = @(
        $helpObject.InputTypes.InputType.Type.Name
    )
    Outputs = @(
        $helpObject.ReturnValues.ReturnValue.Type.Name
    )
    Links = @(
        foreach ($relLink in $this.RelatedLinks.navigationLink) {
            if ($relLink.uri) {
                $relLink.uri
            } else {
                $relLink.text
            }
        }
    )
    Examples = @(
        foreach ($example in $helpObject.Examples.Example) {                    
            # Combine the code and remarks
            $exampleLines = 
                @(
                    $example.Code
                    foreach ($remark in $example.Remarks.text) {
                        if (-not $remark) { continue }
                        $remark
                    }
                ) -join ([Environment]::NewLine) -split '(?&gt;\r\n|\n)' # and split into lines

            # Anything until the first non-comment line is a markdown predicate to the example
            $nonCommentLine = $false
            $markdownLines = @()
            
            # Go thru each line in the example as part of a loop
            $codeBlock = @(foreach ($exampleLine in $exampleLines) {
                if ($exampleLine -match '^\#' -and -not $nonCommentLine) {
                    $markdownLines += $exampleLine -replace '^\#' -replace '^\s+'
                } else {
                    $nonCommentLine = $true
                    $exampleLine
                }
            }) -join [Environment]::NewLine
            [Ordered]@{
                Title = ($example.Title -replace '^[-\s]+' -replace '[-\s]+$')
                Markdown = $markdownLines -join [Environment]::NewLine
                Code = $codeBlock
            }                        
        }        
    )
} | ConvertTo-Json -Depth 10
                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
  <Type>
    <Name>PowerShell.Markdown.Help</Name>
    <Members>
      <ScriptMethod>
        <Name>HideSection</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Hides sections of markdown help
.DESCRIPTION
    Hides sections of a command's markdown help.
#&gt;
param(
# One or more section names.
[ValidateSet('Name','Synopsis','Description','RelatedLinks','Examples','Parameters','Inputs','Outputs','Notes','Story','Syntax')]
[Alias('SectionName')]
[string[]]
$SectionNames
)


$skipSectionNames = @($This.HideSections)
foreach ($SectionName in $SectionNames) {
    if ($skipSectionNames -notcontains $SectionName) {     
        $skipSectionNames += $SectionName 
    }
}

$this | 
    Add-Member NoteProperty HideSections $skipSectionNames -Force

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Save</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Saves a Markdown Help Topic
.DESCRIPTION
    Saves a Markdown Help Topic to a file.
.NOTES
    This will not save to files that have illegal names on Windows.
.EXAMPLE
    (Get-MarkdownHelp Get-MarkdownHelp).Save(".\test.md")
.LINK
    PowerShell.Markdown.Help.ToMarkdown
#&gt;
param(
# The path to the file.
# If this does not exist it will be created.
[string]
$FilePath,

# An optional view.
# This would need to be declared in a .format.ps1xml file by another loaded module.
[string]
$View = 'PowerShell.Markdown.Help'
)

$illegalCharacters = @('&lt;', '&gt;', '|', '?', '*', ':')
$illegalCharacterRegex = '[' + ($illegalCharacters | Foreach-Object { [regex]::Escape($_) }) + ']'
$illegalCharacterReadable = ($illegalCharacters | Foreach-Object { "`"$_`"" }) -join ', '

$filePathWithoutQualifier = Split-Path $filePath -NoQualifier
if ($filePathWithoutQualifier -match $illegalCharacterRegex) {
    Write-Warning "Will not .Save to $filePath, because that path will not be readable on all operating systems. It cannot contain any of the characters $illegalCharacterReadable."
    return
}

if (-not (Test-Path $FilePath)) {
    $createdFile = New-Item -ItemType File -Path $FilePath -Force
    if (-not $createdFile) { return }
}

Set-Content -Path $filePath -Value $this.ToMarkdown($view)

if ($?) {
    Get-Item -Path $FilePath
}
                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ShowSection</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Shows sections of markdown help
.DESCRIPTION
    Shows sections of a command's markdown help.
#&gt;
param(
# One or more section names
[ValidateSet('Name','Synopsis','Description','RelatedLinks','Examples','Parameters','Inputs','Outputs','Notes','Story','Syntax')]
[Alias('SectionName')]
[string[]]
$SectionNames
)

$skipSectionNames = @($This.HideSections)
foreach ($SectionName in $SectionNames) {
    if ($skipSectionNames -contains $SectionName) {     
        $skipSectionNames = @($skipSectionNames -ne $SectionName)
    }
}

$this | 
    Add-Member NoteProperty HideSections $skipSectionNames -Force



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ToMarkdown</Name>
        <Script>
                        &lt;#
.SYNOPSIS
    Returns this topic as a markdown string
.DESCRIPTION
    Returns the content of this help topic as a markdown string.
.EXAMPLE
    (Get-MarkDownHelp Get-MarkDownHelp).ToMarkdown()
#&gt;
param(
# An optional view.
# This would need to be declared in a .format.ps1xml file by another loaded module.
[string]
$View = 'PowerShell.Markdown.Help'
)

($this |
    Format-Custom -View $View |
    Out-String -Width 1mb).Trim()
                    </Script>
      </ScriptMethod>
      <NoteProperty>
        <Name>README</Name>
        <Value>This PSType is used to transform help for a command into Markdown.

To get help for any command as markdown, use `Get-MarkdownHelp`.

~~~PowerShell
$MarkdownHelp = Get-MarkdownHelp Get-MarkdownHelp
$MarkdownHelp
~~~</Value>
      </NoteProperty>
    </Members>
  </Type>
</Types>
